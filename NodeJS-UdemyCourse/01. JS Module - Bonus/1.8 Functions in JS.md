# 1.8 Functions in JS [ 22/08/2025 ]

---

## Function

`function` is a block of code designed to perform a particular task.

- A JavaScript function is defined with theÂ `function`Â keyword, followed by aÂ **name**, followed by parenthesesÂ **()**.
- A JS function is called with `function_name` followed by parenthesis `()`

```jsx
//Defining a hello function
function hello () {
    console.log("Hello..!, How are you");
}

// calling the hello function
hello();
```

## Function parameters & arguments

- `parameters` are the variables declared inside parenthesis `( )` during function definition
- `arguments` are the values passed inside parenthesis `( )` during function calling

```jsx
function sum (parameter1, parameter2) {
    console.log(parameter1+parameter2);
}

sum(4, 8); //4, 8 are the argument1 & 2 respectively
```

<aside>
ðŸ’¡

NOTE:

---

- In JS functions,
    1. order in which arguments are passed is V.IMP [ Since types are not defined at compile time ]
        - If one of the argument is missed, then it will take value of 2nd as `undefined` & gives the o/p without any error
        - If we give more arguments than the parameters defined, then it will only take the arguments required for the defined parameters & ignore the rest.
    2. If  we print the function name [ without parenthesis ]
        - console will print the definition of user defined functions [ In Browser ]
        - console will print the function name saying it is a function [ In Node ]
    3. `typeof` function â†’ function
    4. Always a function returns `undefined` [ if it doesnâ€™t explicitly returns something ]
</aside>

## return

- in general terms, a function will take some input, works on it & then gives us the output
    - in terms of programming language,
        - inputs â†’ arguments
        - processing â†’ block of code
        - output â†’ ?
    - This output is given by a keyword called `return`
- `return` â†’ A keyword used to return some value from a Function

## return (vs) break

- `break` â†’ it exits the block of code without executing the code below
- `return` â†’ it exits the block of code without executing the code below & returns value

## Scope

- `scope` determines accessibility/availability of variables, objects & functions from different parts of code.
- There are 3 types of scopes
    - function scope â†’ Var defined inside the function are NOT accessible outside the function
    - Block scope â†’ Var defined inside the block `{ }` are NOT accessible outside the block `{ }`
        - This scope is NOT applicable to variables defined using `var` keyword
    - Lexical Scope

<aside>
ðŸ’¡

NOTE:

---

- If there is clash between global & function scope
- Always "function" scope wins
</aside>

```jsx
// function scope
let add = 5; // global scope

function functionBlock (n1, n2) {
    let add = n1+n2; // function scope
    return add;
}

console.log(functionBlock(2, 5)); // 7 [without error]
console.log(add); // 5

// block scope
{
    var h = "H";
    let k = "k";
}
console.log(h); // H -> since block scope is NOT valid for var keywords
console.log(k); // error -> due to block scope
```

## Lexical Scope [ Static Scope ]

- **`Lexical (or static) scope`** â†’ Scope of a Variable is Determined **at the time of writing the code [ defining ]**, **not at runtime [ calling ]**
    - JavaScript uses
        - **function-level scoping** (with `var`) and
        - **block-level scoping** (with `let` and `const` from ES6).
    - Inner functions can access variables from their outer (parent) functions, but not vice versa.

```jsx
// Lexical Scope
function outerFn () {
    let x = 10;
    let y = 20;

    function innerFn () {
        console.log(x);
        console.log(y);
    }
    innerFn();
}

outerFn(); // prints both the values of x & y
```

```jsx
// Lexical scope with hoisting
function outerFn1 () {
    function innerFn1 () {
        console.log(x); //lexical scope
        console.log(y); //lexical scope
    }

    let x = 10;
    let y = 20;
    innerFn1();
}
outerFn1(); 
// printsvalues of x & y -> Due to Hoisting
```

```jsx
// Lexical Scope with Closure
function outer() {
  let a = 100;
  return function inner() {
    console.log(a);
  };
}

let innerFunc = outer(); 
// outer() runs, returns inner()

innerFunc(); 
// Logs 100, because Closure keeps `a` alive
```

## Importance

- Lexical scope is the foundation for **closures**,
    - A **`closure`** is a function
        - that **Remembers** the variables & functions from the **lexical scope [** in which it was defined ]
        - even after the outer function has finished executing
- It helps avoid naming conflicts and makes code more predictable and maintainable

```jsx
function outer() {
  let a = 100;

  function mid() {
    let b = 200;

    return function inner() {
      console.log(a + b); // Accessing both `a` and `b`
    };
  }

  return mid();
}

let innerFunc = outer();
a = 1000;    // Reassigning 'a' globally has no effect
b = 2000;
innerFunc(); // Logs 300 [ due to closure ]
```

- Here,
    - Each function **remembers the scope it was created in**, layering access from `inner` â†’ `mid` â†’ `outer`
- Finally,
    - **Lexical scope** means `inner()` keeps the environment where it was **created**, not where it's **called**.
    - So even though global `a` and `b` are `1000` and `2000`, `inner()` uses the **local** `a` and `b` from when it was **defined** â€” that's lexical scope.

## Higher Order Functions

`Higher Order Function` â†’ A function that does either

- takes one (or) multiple functions as arguments
- returns a function

Simply, A function which takes another function as argument ( or ) returns another function

```jsx
//taking onr (or) more functions as an argumets
function multipleGreet (func, n) {
    for (let i=0; i<n; i++) {
        func();
    }
}
let greet = function() {
    console.log("Hello");
}

multipleGreet(greet, 3); //prints Hello 3 times
/**
 *  - Here, multipleGreet -> a HOF (as it takes a function as an argument)
 *  - greet -> Not a function but a variable having function as a Value/Expression
*/
```

## Callback

- Higher Order Function is a function which takes another function as an argument (or) returns a function
- A callback is a function passed as an argument to another function [ so as to be executed later ]
    - This technique allows a function to call another function

<aside>
ðŸ’¡ When you pass a function as an argument, remember not to use parenthesis.

</aside>

## Challenges

```jsx
/*
1. Write a function named `makeTea' that takes one
parameter, `type0fTea', and returns a string like
`"Making green tea" when called with '"green tea".
Store the result in a variable named `teaOrder'.
*/
function makeTea (type0fTea) {
    return `Making ${type0fTea}`;
}

let teaOrder = makeTea("green tea");
console.log(teaOrder);

/*
2. Create a function named `orderTea' that takes one parameter, 'teaType'. 
Inside this function, create another function named `confirmOrder' that 
returns a message like '"Order confirmed for chai".
Call 'confirmOrder' from within `orderTea' and return the result.
*/
function orderTea (teaType) {
    function confirmOrder () {
        return `Order Confirmed for ${teaType}`;
    }
    return confirmOrder();
}

console.log(orderTea("Leamon Tea"));

/*
3. Write an arrow function named `calculateTotal that
takes two parameters: `price' and `quantity . The
function should return the total cost by multiplying the
`price' and `quantity .
Store the result in a variable named `totalCost'.
*/
let calculateTotal = (price, quantity) => {
    return price * quantity;
}

let totalCost = calculateTotal(100, 5)
console.log(totalCost);
```

```jsx
/*
4. Write a function named `processTeaOrder' that takes
another function, `makeTea', as a parameter and calls it
with the argument '"earl grey"'.
Return the result of calling `makeTea'.
*/
function processTeaOrder (makeTea) {
    return makeTea("earl grey");
}

function makeTea (tea) {
    return `Making ${tea}`;
}

console.log(processTeaOrder(makeTea));

/*
5. Write a function named `createTeaMaker' that returns
another function. The returned function should take one
parameter, 'teaType', and return a message like `"Making
green tea".
Store the returned function in a variable named
teaMaker' and call it with '"green tea"'.
*/
function createTeaMaker () {
    return function (teaType) {
        return `Making ${teaType}`;
    }
}

let teaMaker = createTeaMaker();
console.log(teaMaker);
console.log(teaMaker());
console.log(teaMaker("Green Tea"));
```