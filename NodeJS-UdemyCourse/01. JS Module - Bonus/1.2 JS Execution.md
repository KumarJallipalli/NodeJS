# 1.2 JS Execution [ 21/08/2025 ]

---

## How to Execute a JS file

1. Have a JS file [ with some JS code in it ]
    
    ```jsx
    console.log("Hello JavaScript);
    ```
    
2. Execute the JS file using the command
    - Command â†’ `node file_name`
    - This Command Executes the JS Code & Prints Output onto Console

<aside>
ðŸ’¡

NOTE:

---

- JS is Single Threaded & Synchronous Language
    - single thread **â†’** Executes One Command/thing/Line of Code at a time [ in a sequence ]
    - Synchronous â†’ Executes next line of Code only when the Current line of code is completed
</aside>

## Behind the Scenes of Execution

1. **Parsing**
    - The JS engine reads the code and parses it **line by line**.
    - It creates an **Abstract Syntax Tree (AST)** â€“ a structured representation of the code.
    - This phase checks for **syntax errors** and prepares for execution.
2. **Compilation (Just-In-Time Compilation)**
    - Modern engines like **V8** use **JIT compilation**:
        - Code is **not interpreted line by line** anymore (that's slow).
        - Instead, it's **compiled to bytecode** and eventually into **machine code** for faster execution.
        - V8 uses:
            - **Ignition** â†’ bytecode compiler
            - **TurboFan** â†’ optimizing compiler that turns hot (frequently run) code into machine code

<aside>
ðŸ’¡

NOTE:

---

This is Very Clearly explained by Saini in his Node lectures

</aside>

## Before Execution

1. **Creation Phase (Memory Allocation)**
    - Before execution begins, JS performs a **memory setup**:
        - A **Global Execution Context (GEC)** is created.
        - It has 2 parts:
            - **Memory Component (Variable Environment)** â€“ stores variables and functions
            - **Code Component (Thread of Execution)** â€“ executes the code line by line
        - In this phase:
            - Variables are **hoisted** with initial value `undefined`
            - Functions are **hoisted in full** (can be called before they are defined)
2. **Execution Phase**
    - JS runs the code **line-by-line**, replacing `undefined` with actual values.
    - It also executes any function calls, which create new **Function Execution Contexts**.
    
    These contexts are managed using the:
    
3. **Call Stack**
    - The **Call Stack** keeps track of function calls.
    - Each time a function is called, a new **Execution Context** is pushed onto the stack.
    - When the function finishes, its context is **popped** off the stack.
4. **Memory Heap**
    - JS uses the **memory heap** to store reference types (objects, arrays, functions).
    - Allocated during execution when needed.
5. **Asynchronous Code (Web APIs, Callback Queue, Event Loop)**
    - Even though JS is single-threaded, **asynchronous code** (like `setTimeout`, AJAX, promises) is handled via:
        - **Web APIs** (provided by browser, not JS itself)
        - **Callback Queue** (or Task Queue)
        - **Event Loop** â€“ keeps checking if the call stack is empty and then pushes async callbacks from the queue

## Summary

1. Parse code â†’ AST
2. Create Global Execution Context
3. Memory Allocation (Hoisting)
4. Execute Code Line by Line
5. Manage Execution Contexts via Call Stack
6. Handle async with Web APIs + Event Loop