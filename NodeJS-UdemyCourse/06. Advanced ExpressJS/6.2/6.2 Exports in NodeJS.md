# 6.2 Exports in NodeJS [ 26/05/2025 ]

---

## Types of Middleware

- Global Level Middleware â†’ will always run on every Request
- Route Level Middleware â†’ will only run on specified Route
- Router Middleware [ Need Router knowledge in Express ]

<aside>
ðŸ’¡

NOTE:

---

- WKT, We can have any No. of middlewareâ€™s
- Similarly,
    - We can have N number of Global Level Middlewareâ€™s
    - We can have N number of Route level Middlewareâ€™s
</aside>

Global Level & Route Level

```jsx
const express = require('express');

const app = express();

const PORT = 8000;

function globalLevelMiddleware (req, res, next) {
    console.log("This is Global Level Middleware, As it always runs")
    next();
}

app.use(globalLevelMiddleware());

app.get('/', (req, res) => {
    console.log("This is Final Middleware, as it is terminating Req");
    res.json({Message: "Response is Sent"});
})

app.listen(PORT, () => console.log(`Server is Running on PORT: ${PORT}`)
```

```jsx
const express = require('express');

const app = express();

const PORT = 8000;

function RouteLevelMiddleware (req, res, next) {
    console.log("This is Route Level Middleware");
    next();
}

app.get('/about', RouteLevelMiddleware);

app.get('/', (req, res) => {
    console.log("This is Final Middleware, as it is terminating Req");
    res.json({Message: "Response is Sent"});
})
// "(req, res) => {}" inside app.get() is also a Route Level Middleware fn

app.listen(PORT, () => console.log(`Server is Running on PORT: ${PORT}`));
```

## Exports

- `exports` â†’ Allows us to E**xpose the Code (functions, objects, variables, classes, etc.)** from one module (file)
    - so that, it can be used in another module via `require()`
- Node JS uses Common JS module System
    - Which utilizes `module.exports`Â andÂ `require()`.

We can Export using 2 ways

1. **Using `module.exports`**

- This is the standard way to export a single value (function, object, class, etc.).
    
    ```jsx
    // math.js
    function add(a, b) {
      return a + b;
    }
    module.exports = add;
    
    // app.js
    const add = require('./math');
    console.log(add(2, 3)); // 5
    ```
    
- To export Multiple Values
    
    ```jsx
    // calculator.js
    const add = (a, b) => a + b;
    const subtract = (a, b) => a - b;
    const PI = 3.14159;
    
    module.exports = {
      add,
      subtract,
      PI
    };
    
    // app.js
    const calculator = require('./calculator.js');
    console.log(calculator.add(5, 3)); // Output: 8
    console.log(calculator.PI); // Output: 3.14159
    
    // Or, using object destructuring for specific exports:
    const { add, PI } = require('./calculator.js');
    console.log(add(10, 2)); // Output: 12
    console.log(PI); // Output: 3.14159
    ```
    

1. **Using `exports` (shorthand)**
    - This is a shortcut for adding multiple properties to `module.exports`.
        
        ```jsx
        // utils.js
        exports.greet = function(name) {
          return `Hello, ${name}!`;
        };
        
        exports.farewell = function(name) {
          return `Goodbye, ${name}!`;
        };
        
        // app.js
        const utils = require('./utils');
        console.log(utils.greet('Paris')); // Hello, Paris!
        ```
        

<aside>
ðŸ’¡

NOTE:

---

- `exports`Â is a reference toÂ `module.exports`.
- If you reassignÂ `exports`Â (e.g.,Â `exports = {}`), you break this reference,
- andÂ `module.exports`Â will remain the original object (or an empty object if nothing was previously assigned to it).
- It is generally recommended to useÂ `module.exports`Â consistently to avoid potential confusion.

Behind the Scenes

- Every file in Node.js is treated as a module. [ Not same in ES Module System ]
- `module.exports` is the actual object returned when you `require()` a file.
- `exports` is just a reference to `module.exports`â€”until you overwrite it.
</aside>

## NOTE

- `module.exports` is an Empty Object â†’ `{}`
- Hence, we can define it 2 Ways

```jsx
module.exports = {
    marks: marks,
    sum: sum
};
```

```jsx
module.exports.marks = marks
module.exports.sum =  sum
```

Both are Same 

Code

```jsx
// math.js
function add (a, b) {
    return a + b;
}

function sub (a, b) {
    return a - b;
}

function mul (a, b) {
    return a * b;
}

function div (a, b) {
    return a / b;
}

// Exporting
module.exports = {
    add,
    sub,
    mul,
}

module.exports.div = div;
```

```jsx
// index.js

// importing using "require"
const { add, sub, mul, div } = require('./math');

console.log(add(2,7));
console.log(sub(2,7));
console.log(mul(2,7));
console.log(div(2,7));
```

`

```jsx
// temp.js
exports.greet = function (name) {
    console.log(`Hello ${name}`);
}

exports.welcome = function (name) {
    console.log(`Welcome Home ${name}`);
}

exports.name = "Paris";
```

```jsx
// index.js
const { greet, welcome, name } = require('./temp');

console.log(name);
greet(name); 
welcome(name);
```

```jsx
// temp.js
exports.greet = function (name) {
    console.log(`Hello ${name}`);
}

exports.welcome = function (name) {
    console.log(`Welcome Home ${name}`);
}

exports.name = "Paris";

const age = 20;
const city = "Lodon";

module.exports = {age, city}
// This replaces the above shorthand notation
// Hence, greet, welcome, name are not exported [ as overwritten ]
```

```jsx
// index.js
const { greet, welcome, name, age, city } = require('./temp');

console.log(name);
console.log(age);
console.log(city);
console.log(greet);
console.log(welcome);
// greet(name);   Throws error
// welcome(name);
```