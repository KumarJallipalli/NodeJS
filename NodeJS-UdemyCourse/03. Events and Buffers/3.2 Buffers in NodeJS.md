# Buffers in NodeJS [ 23/08/2025 ]

---

## Reason

- WKT, **JavaScript was originally built for web browsers**
- And the kind of data web pages mostly dealt with at the time was **text**
- As a result, JavaScript's design focused heavily on **string manipulation.** things like:
    - Concatenating strings
    - Searching and replacing text
    - Encoding and decoding text
- Hence, JS has No native support for binary data
    - JavaScript didnâ€™t have data types like `byte`, `int16`, or `float64` [ that lower-level languages like C or Java had ]
    - You couldn't directly interact with raw memory or byte sequences.
    - This made it **difficult or impossible** to do things like:
        - Work with images or videos in binary form
        - Read raw data from files or network sockets
        - Implement binary protocols
- But Node.js was designed for **I/O-heavy tasks**, and a lot of I/O involves **binary data**
    - Hence, Node.js needed to handle:
        - File I/O (reading image files, videos, etc.)
        - Network I/O (sockets, TCP streams)
        - Binary protocols (e.g., HTTP headers, compressed files)
- So, Node.js introduced the **`Buffer` class** to provide access to **raw binary data**, filling in a key gap in JavaScriptâ€™s capabilities.

### ðŸ§  Analogy

- Imagine JavaScript as a language that only understood and manipulated **sentences written on paper**,
    - but had no concept of **ink**, **pixels**, or **audio waves**.
    - Thatâ€™s fine for webpages, but not for working directly with images, sound, or binary files.
- The `Buffer` is like giving JavaScript access to the **underlying bytes** â€” the raw ink
    - so it can manipulate things much closer to the hardware or file system.

## What Are Buffers in Node.js?

- Generally,
    - A Buffer is a temporary storage area for binary data.
- But In Node**,**
    - **Buffer**  [is a built-in class ] that allows you to work with **binary data** directly
    - Buffer â†’ memory allocated outside of the V8 JavaScript engine, which can store raw binary data.
    - `Buffer`Â objects are used to represent a fixed-length sequence of bytes. [ similar to an array of integers ]
- JS doesn't support direct binary manipulation (like C/C++),
    - so Node uses Buffers to handle raw data efficiently.

## why Do We Need Buffers?

- JavaScript Strings are UTF-16 encoded, making direct binary data handling inefficient.
- Buffers store binary data outside v8's heap memory
- Useful when working with:
    - File System (fs module)
    - Networking (TCP, UDP, WebSocket)
    - Streams (handling chunks of data)

Examples

```jsx
const { Buffer } = require('node:buffer');

const buf = Buffer.alloc(6);
// alloc() --> Allocates a new Buffer of size bytes. 
// If fill is undefined, the Buffer will be zero-filled.

console.log(buf);

const bufFill = Buffer.alloc(8, "Paris");
// This repeates the memory Allocation
// Like: for Paris Alloc is --> 50 61 72 69 73
// But: for 8 Paris Alloc is --> 50 61 72 69 73 50 61 72
// i.e., It generally takes 5 bytes & remaining 3 bytes is repeated

console.log(bufFill);

// As Buffer represent a fixed-length sequence of bytes
// We can access any of it's byte
console.log(bufFill[4]); 
console.log(bufFill[5].toString()); 

const city = "Paris";
const bufCity = Buffer.from(city);
// from() --> Creates a new Buffer from string

console.log(bufCity);

const city2 = "Paris";
const bufCity2 = Buffer.from(city);
console.log(bufCity2);

const bufCity3 = Buffer.from("London");
console.log(bufCity3);
console.log(bufCity3.toString());
```

```jsx
// Writing into Buffer
const buff = Buffer.alloc(8);
buff.write("New York");
console.log(buff);
console.log(buff.toString('utf-8', 0, 5));

// Buffer manipulation
const bufff = Buffer.from("chai");
console.log(bufff);
bufff[0] = 0x4a;
console.log(bufff);
console.log(bufff.toString());
console.log(bufff.length);

const buff1 = Buffer.from("Paris");
const buff2 = Buffer.from("Hilton");
const merge = Buffer.concat([buff1, buff2]);
console.log(merge);
console.log(merge.toString());

console.log(merge[1]);
console.log(merge[2]);
```